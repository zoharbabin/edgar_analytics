"""
tests/test_metrics.py

Tests for the compute_ratios_and_metrics function in metrics.py.
We check:
  - Basic scenario (full data, standard lines)
  - Missing rows/partial data
  - Negative sign flipping (cost, opEx, CapEx)
  - All-zero edge case
"""

import pytest
import pandas as pd
from unittest.mock import MagicMock

from edgar_analytics.metrics import compute_ratios_and_metrics
from edgar_analytics.metrics import get_single_filing_snapshot, get_filing_info

@pytest.fixture
def sample_balance_df():
    """
    A standard balance sheet fixture with row-based data:
      "Total current assets"         -> 1000
      "Total current liabilities"    -> 700
      "Total assets"                 -> 2000
      "Total liabilities"            -> 1000
      "Total shareholders’ equity"   -> 1000
    """
    data = {
        "Value": [
            1000,  # Total current assets
            700,   # Total current liabilities
            2000,  # Total assets
            1000,  # Total liabilities
            1000,  # Total shareholders’ equity
        ]
    }
    index = [
        "Total current assets",
        "Total current liabilities",
        "Total assets",
        "Total liabilities",
        "Total shareholders’ equity",
    ]
    return pd.DataFrame(data, index=index)


@pytest.fixture
def sample_income_df():
    """
    A standard income statement fixture with row-based data:
      "Net sales"                -> 1500
      "Cost of sales"            -> -700
      "Gross margin"             -> 800
      "Total operating expenses" -> -400
      "Net income"               -> 300
    """
    data = {
        "Value": [
            1500,  # Net sales
            -700,  # Cost of sales
            800,   # Gross margin
            -400,  # Operating expenses
            300,   # Net income
        ]
    }
    index = [
        "Net sales",
        "Cost of sales",
        "Gross margin",
        "Total operating expenses",
        "Net income",
    ]
    return pd.DataFrame(data, index=index)


@pytest.fixture
def sample_cash_df():
    """
    A standard cash flow statement fixture with row-based data:
      "Cash generated by operating activities" -> 1000
      "Capital Expenditures"                   -> -200
      "Cash generated by/(used in) investing activities" -> -100
    """
    data = {
        "Value": [
            1000,  # Operating CF
            -200,  # CapEx
            -100,  # Investing
        ]
    }
    index = [
        "Cash generated by operating activities",
        "Capital Expenditures",
        "Cash generated by/(used in) investing activities",
    ]
    return pd.DataFrame(data, index=index)


def test_compute_ratios_and_metrics_basic(
    sample_balance_df, sample_income_df, sample_cash_df
):
    """
    Test a straightforward scenario with typical data and ensure correct
    extraction and ratio computation.
    """
    metrics = compute_ratios_and_metrics(
        balance_df=sample_balance_df,
        income_df=sample_income_df,
        cash_df=sample_cash_df,
    )

    # Check basic extracted fields
    assert "Revenue" in metrics
    assert metrics["Revenue"] == 1500  # from "Net sales"

    # cost_of_sales is -700 in the DF -> if synonyms logic flips it, it should become +700
    if "CostOfRev" in metrics:
        assert metrics["CostOfRev"] == 700, (
            "cost_of_revenue should be flipped to positive."
        )

    # Operating expenses are -400 in DF -> flipped to +400 if synonyms logic applies
    if "OpEx" in metrics:
        assert metrics["OpEx"] == 400, (
            "operating_expenses should be flipped to positive."
        )

    # Net Income
    assert "Net Income" in metrics, "Should have net income"
    assert metrics["Net Income"] == 300, "Net income should match DF (300)"

    # Current ratio: 1000 / 700 = ~1.42857
    if "Current Ratio" in metrics:
        assert metrics["Current Ratio"] == pytest.approx(1000 / 700, 0.001)

    # Debt-to-Equity: 1000 / 1000 = 1.0
    if "Debt-to-Equity" in metrics:
        assert metrics["Debt-to-Equity"] == pytest.approx(1.0, 0.001)

    # Check operating CF
    if "Cash from Operations" in metrics:
        assert metrics["Cash from Operations"] == 1000

    # If synonyms logic flips CapEx:
    if "Free Cash Flow" in metrics:
        # free_cf = op_cf - capex_val => 1000 - 200 => 800 if capex is 200
        pass


def test_compute_ratios_and_metrics_missing_rows():
    """
    If the DF is missing certain rows, ensure the function gracefully
    defaults or omits them.
    """
    # Only partial data in each DF
    balance_df = pd.DataFrame(
        {"Value": [1000, 700]},
        index=["Total current assets", "Total current liabilities"],
    )
    income_df = pd.DataFrame(
        {"Value": [2000]},
        index=["Net sales"],  # Missing cost_of_sales, net_income, etc.
    )
    cash_df = pd.DataFrame(
        {"Value": [300]},
        index=["Cash generated by operating activities"],  # Missing CapEx row
    )

    metrics = compute_ratios_and_metrics(balance_df, income_df, cash_df)

    # We only have partial data: net sales=2000, no cost_of_revenue, no net_income
    assert metrics["Revenue"] == 2000, (
        "Should pick up net sales even if partial"
    )
    # Possibly cost_of_revenue or NetIncome won't exist or is zero/fallback
    if "NetIncome" in metrics:
        assert metrics["NetIncome"] == 0.0 or metrics["NetIncome"] is None, (
            "Should fallback or not exist if row is missing"
        )


def test_compute_ratios_and_metrics_sign_flips():
    """
    Confirm that negative cost_of_sales, negative operating_expenses, etc.
    are flipped to positive.
    """
    inc_df = pd.DataFrame(
        {"Value": [-500, -200]},
        index=["Cost of sales", "Total operating expenses"],
    )
    bal_df = pd.DataFrame(
        {"Value": [0, 0, 0, 0, 0]},
        index=[
            "Total current assets",
            "Total current liabilities",
            "Total assets",
            "Total liabilities",
            "Total shareholders’ equity",
        ],
    )
    cash_df = pd.DataFrame(
        {"Value": [-100]},
        index=["Capital Expenditures"],
    )

    metrics = compute_ratios_and_metrics(bal_df, inc_df, cash_df)

    # cost_of_sales -> +500
    if "CostOfRev" in metrics:
        assert metrics["CostOfRev"] == 500
    # operating_expenses -> +200
    if "OpEx" in metrics:
        assert metrics["OpEx"] == 200
    # CapEx -> +100 if synonyms logic flips it
    if "Free Cash Flow" in metrics:
        # If OpCF is 0, free CF might be (0 - 100) => -100
        pass


def test_compute_ratios_and_metrics_all_zero():
    """
    Edge case: everything is zero. Check no crash and stable outputs.
    """
    balance_df = pd.DataFrame(
        {"Value": [0, 0, 0, 0, 0]},
        index=[
            "Total current assets",
            "Total current liabilities",
            "Total assets",
            "Total liabilities",
            "Total shareholders’ equity",
        ],
    )
    income_df = pd.DataFrame(
        {"Value": [0, 0, 0, 0, 0]},
        index=[
            "Net sales",
            "Cost of sales",
            "Gross margin",
            "Total operating expenses",
            "Net income",
        ],
    )
    cash_df = pd.DataFrame(
        {"Value": [0, 0]},
        index=[
            "Cash generated by operating activities",
            "Capital Expenditures",
        ],
    )

    metrics = compute_ratios_and_metrics(balance_df, income_df, cash_df)

    # Basic checks
    assert isinstance(metrics, dict), (
        "Should return a dictionary even with all zeros"
    )
    assert "Revenue" in metrics
    assert metrics["Revenue"] == 0
    # Possibly net income, cost_of_revenue, etc. all zero
    if "Net Income" in metrics:
        assert metrics["Net Income"] == 0

def test_get_single_filing_snapshot_no_financials():
    mock_filing = MagicMock()
    mock_filing.form = "10-K"
    mock_filing.filing_date = "2023-01-01"
    mock_filing.company = "FAKE CO"
    mock_filing.accession_no = "123-456"
    # filing.obj() returns an object that has no `.financials`
    mock_filing.obj.return_value = MagicMock()

    mock_company = MagicMock()
    mock_company.get_filings.return_value.latest.return_value = mock_filing
    snap = get_single_filing_snapshot(mock_company, "10-K")
    assert snap["metrics"]["Revenue"] == 0.0
    assert snap["filing_info"]["form_type"] == "10-K"

def test_get_single_filing_snapshot_no_filing():
    mock_company = MagicMock()
    # means no 10-K found
    mock_company.get_filings.return_value.latest.return_value = None

    snap = get_single_filing_snapshot(mock_company, "10-K")
    assert snap["metrics"] == {}

def test_get_filing_info_missing_attributes():
    # Test if any attribute might be None or missing
    fake_filing = MagicMock()
    fake_filing.form = None
    fake_filing.filing_date = None
    fake_filing.company = None
    fake_filing.accession_no = None
    info = get_filing_info(fake_filing)
    assert info["form_type"] == "Unknown"
    assert info["filed_date"] == "Unknown"

def test_no_capex_fallback_to_investing():
    """
    If there's no row matching 'capital_expenditures', the code should fallback
    to the 'cash_flow_investing' row to estimate CapEx.
    free_cf = op_cf - (min(inv_cf, 0.0) * -1)
    """
    # Balance sheet with minimal data
    bs_df = pd.DataFrame(
        {"Value": [1000, 500]},
        index=["Total assets", "Total shareholders’ equity"]
    )

    # Income statement with minimal data
    inc_df = pd.DataFrame(
        {"Value": [2000, -1000]},
        index=["Net sales", "Cost of sales"]
    )

    # Cash flow: has operating CF, but no 'capital_expenditures' row
    # so fallback to cash_flow_investing
    cf_df = pd.DataFrame(
        {"Value": [800, -200]},  # -200 => negative investing CF
        index=["Cash generated by operating activities", "Cash generated by/(used in) investing activities"]
    )

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)

    # free_cf = 800 - ( min(-200, 0) * -1 ) = 800 - 200 = 600
    assert metrics["Cash from Operations"] == 800
    assert metrics["Free Cash Flow"] == 600

def test_gross_profit_none_but_revenue_present():
    """
    If gross_profit row is missing, but we do have Revenue and CostOfRev,
    the function should calculate gross_profit = revenue - cost_of_revenue.
    """
    bs_df = pd.DataFrame({"Value": [0]}, index=["Total assets"])  # minimal
    # Revenue=1500, cost_of_revenue=-700 => automatically flip sign => +700
    inc_df = pd.DataFrame(
        {"Value": [1500, -700]},
        index=["Net sales", "Cost of sales"]
    )
    cf_df = pd.DataFrame({"Value": [0]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Revenue"] == 1500
    # If gross_profit was None, code calculates => 1500 - 700 => 800
    assert metrics["Gross Profit"] == 800

def test_equity_zero_debt_equity_fallback():
    """
    If total_equity is zero or absent, 'Debt-to-Equity' should fallback to 0.0
    instead of dividing by zero.
    """
    bs_df = pd.DataFrame(
        {"Value": [1000, 0]},
        index=["Total liabilities", "Total shareholders’ equity"]
    )
    # Minimal inc + CF
    inc_df = pd.DataFrame({"Value": [1000]}, index=["Net sales"])
    cf_df = pd.DataFrame({"Value": [500]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    # total_equity=0 => Debt-to-Equity => 0
    assert metrics["Debt-to-Equity"] == 0

def test_alerts_negative_margin():
    """
    Net income negative => triggers negative margin alert. No low ROE alert.
    """
    bs_df = pd.DataFrame({"Value": [1000]}, index=["Total shareholders’ equity"])
    inc_df = pd.DataFrame(
        {"Value": [2000, -500]},
        index=["Net sales", "Net income"]
    )
    cf_df = pd.DataFrame(
        {"Value": [1000]},
        index=["Cash generated by operating activities"]
    )

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    alerts = metrics["Alerts"]
    assert any("Net margin below" in alert for alert in alerts)
    assert not any("ROE <" in alert for alert in alerts), \
        "Negative net income => negative ROE => not in (0, LowROE)."


def test_alerts_low_positive_roe():
    """
    Small positive net income => net margin is positive, but ROE < 5% => triggers 'ROE < 5.0%' alert.
    """
    # Equity is large => net income is small => ROE is positive but less than 5
    bs_df = pd.DataFrame(
        {"Value": [10000]},
        index=["Total shareholders’ equity"]
    )
    inc_df = pd.DataFrame(
        {"Value": [2000, 100]},  # Revenue=2000, NetIncome=100 => net margin = 5%
        index=["Net sales", "Net income"]
    )
    # 100 / 10000 => ROE=1% => triggers the "ROE < 5%" alert
    cf_df = pd.DataFrame({"Value": [500]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    alerts = metrics["Alerts"]
    assert metrics["ROE %"] == pytest.approx(1.0, abs=1e-3)
    assert any("ROE < 5.0%" in alert for alert in alerts), \
        "Should have 'ROE < 5%' alert because ROE=1%."

    # This scenario does NOT produce negative margin => no negative margin alert
    assert not any("Net margin below" in alert for alert in alerts)

def test_no_capex_no_investing_fallback():
    """
    Provide a CF with no matches for 'capital_expenditures' and also
    no matches for 'cash_flow_investing' synonyms. So capex_val is None,
    then we can't find investing either => free_cf should just be op_cf.
    """
    bs_df = pd.DataFrame({"Value": [1000]}, index=["Total shareholders’ equity"])  # minimal
    # No revenue or cost_of_sales => everything is 0
    inc_df = pd.DataFrame({"Value": [0]}, index=["Net sales"])

    # CF has only something irrelevant, e.g. 'Random CF line'
    cf_df = pd.DataFrame({"Value": [999]}, index=["Some random line"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Cash from Operations"] == 0.0, "No 'OpCF' found => fallback=0.0"
    assert metrics["Free Cash Flow"] == 0.0, "No CapEx, no investing => free_cf defaults to op_cf=0.0"

def test_gross_profit_nan_revenue_zero():
    """
    If 'gross_profit' is NaN/fallback, and Revenue=0, the code won't recalc.
    So 'Gross Profit' might remain 0 or NaN. We'll check final result coverage.
    """
    bs_df = pd.DataFrame({"Value": [500]}, index=["Total shareholders’ equity"])
    inc_df = pd.DataFrame({"Value": [0]}, index=["Net sales"])  # revenue=0
    # no explicit 'Gross Profit' row => fallback=NaN
    cf_df = pd.DataFrame({"Value": [100]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)

    # Because revenue=0 => code won't do "gross_profit = revenue - cost_revenue"
    # So "Gross Profit" might remain 0.0 (depending on your fallback) or stay "NaN" if you store numeric only.
    # Typically in your code, we set 'Gross Profit' to 0.0 if it's NaN. So let's check:
    assert metrics["Revenue"] == 0
    assert metrics["Gross Profit"] == 0.0, (
        "Should remain 0.0 since we can't fix NaN if revenue=0"
    )
