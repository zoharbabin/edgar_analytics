# tests/test_metrics.py
"""
tests/test_metrics.py

Tests for the compute_ratios_and_metrics function in metrics.py.
We check:
  - Basic scenario (full data, standard lines)
  - Missing rows/partial data
  - Negative sign flipping (cost, opEx, CapEx)
  - All-zero edge case
"""

import pytest
import pandas as pd
from unittest.mock import MagicMock

from edgar_analytics.metrics import (
    compute_ratios_and_metrics,
    get_single_filing_snapshot,
    get_filing_info,
)

@pytest.fixture
def sample_balance_df():
    """
    A standard balance sheet fixture with row-based data:
      "Total current assets"         -> 1000
      "Total current liabilities"    -> 700
      "Total assets"                 -> 2000
      "Total liabilities"            -> 1000
      "Total shareholders’ equity"   -> 1000
    """
    data = {
        "Value": [
            1000,  # Total current assets
            700,   # Total current liabilities
            2000,  # Total assets
            1000,  # Total liabilities
            1000,  # Total shareholders’ equity
        ]
    }
    index = [
        "Total current assets",
        "Total current liabilities",
        "Total assets",
        "Total liabilities",
        "Total shareholders’ equity",
    ]
    return pd.DataFrame(data, index=index)


@pytest.fixture
def sample_income_df():
    """
    A standard income statement fixture with row-based data:
      "Net sales"                -> 1500
      "Cost of sales"            -> -700
      "Gross margin"             -> 800
      "Total operating expenses" -> -400
      "Net income"               -> 300
    """
    data = {
        "Value": [
            1500,  # Net sales
            -700,  # Cost of sales
            800,   # Gross margin
            -400,  # Operating expenses
            300,   # Net income
        ]
    }
    index = [
        "Net sales",
        "Cost of sales",
        "Gross margin",
        "Total operating expenses",
        "Net income",
    ]
    return pd.DataFrame(data, index=index)


@pytest.fixture
def sample_cash_df():
    """
    A standard cash flow statement fixture with row-based data:
      "Cash generated by operating activities" -> 1000
      "Capital Expenditures"                   -> -200
      "Cash generated by/(used in) investing activities" -> -100
    """
    data = {
        "Value": [
            1000,  # Operating CF
            -200,  # CapEx
            -100,  # Investing
        ]
    }
    index = [
        "Cash generated by operating activities",
        "Capital Expenditures",
        "Cash generated by/(used in) investing activities",
    ]
    return pd.DataFrame(data, index=index)


def test_compute_ratios_and_metrics_basic(
    sample_balance_df, sample_income_df, sample_cash_df
):
    """
    Test a straightforward scenario with typical data and ensure correct
    extraction and ratio computation.
    """
    metrics = compute_ratios_and_metrics(
        balance_df=sample_balance_df,
        income_df=sample_income_df,
        cash_df=sample_cash_df,
    )

    # Basic fields
    assert "Revenue" in metrics
    assert metrics["Revenue"] == 1500, "Revenue should match Net sales=1500"

    # cost_of_sales is -700 => flipped to +700 => stored in "CostOfRev"
    assert "CostOfRev" in metrics, "We expect a 'CostOfRev' key from the new code"
    assert metrics["CostOfRev"] == 700, "cost_of_revenue should be flipped to positive"

    # Operating expenses are -400 => flipped to +400 => stored in "OpEx"
    assert "OpEx" in metrics
    assert metrics["OpEx"] == 400, "operating_expenses should be flipped to positive"

    # Net Income
    assert "Net Income" in metrics
    assert metrics["Net Income"] == 300

    # Check basic balance ratios
    assert metrics["Current Ratio"] == pytest.approx(1000 / 700, 0.001)
    assert metrics["Debt-to-Equity"] == pytest.approx(1.0, 0.001)  # 1000 / 1000

    # Check Operating CF => 1000, CapEx => 200 => Free CF => 800
    assert metrics["Cash from Operations"] == 1000
    assert metrics["Free Cash Flow"] == 800

    # Check EBIT & EBITDA approx
    assert "EBIT (approx)" in metrics
    assert "EBITDA (approx)" in metrics


def test_compute_ratios_and_metrics_missing_rows():
    """
    If the DF is missing certain rows, ensure the function gracefully
    defaults or omits them.
    """
    # Only partial data in each DF
    balance_df = pd.DataFrame(
        {"Value": [1000, 700]},
        index=["Total current assets", "Total current liabilities"],
    )
    income_df = pd.DataFrame(
        {"Value": [2000]},
        index=["Net sales"],  # Missing cost_of_sales, net_income, etc.
    )
    cash_df = pd.DataFrame(
        {"Value": [300]},
        index=["Cash generated by operating activities"],  # Missing CapEx row
    )

    metrics = compute_ratios_and_metrics(balance_df, income_df, cash_df)

    # We only have partial data: net sales=2000
    assert metrics["Revenue"] == 2000
    # Possibly cost_of_revenue, NetIncome => 0 if missing
    assert metrics["Net Income"] == 0.0, "Should default to 0.0 if net_income row missing"
    assert metrics["CostOfRev"] == 0.0, "No row => fallback=0 => no sign flip needed"


def test_compute_ratios_and_metrics_sign_flips():
    """
    Confirm that negative cost_of_sales, negative operating_expenses, etc.
    are flipped to positive.
    """
    inc_df = pd.DataFrame(
        {"Value": [-500, -200]},
        index=["Cost of sales", "Total operating expenses"],
    )
    bal_df = pd.DataFrame(
        {"Value": [0, 0, 0, 0, 0]},
        index=[
            "Total current assets",
            "Total current liabilities",
            "Total assets",
            "Total liabilities",
            "Total shareholders’ equity",
        ],
    )
    cash_df = pd.DataFrame(
        {"Value": [-100]},
        index=["Capital Expenditures"],
    )

    metrics = compute_ratios_and_metrics(bal_df, inc_df, cash_df)

    # Check flips
    assert metrics["CostOfRev"] == 500, "Should flip negative cost_of_sales to 500"
    assert metrics["OpEx"] == 200, "Should flip negative operating_expenses to 200"
    # If no op_cf => 0, then free CF => -100 if flipping CapEx to +100
    # But let's ensure code doesn't break
    assert metrics["Free Cash Flow"] == -100, (
        "With 0 operating CF and +100 CapEx => free CF = 0 - 100 = -100"
    )


def test_compute_ratios_and_metrics_all_zero():
    """
    Edge case: everything is zero. Check no crash and stable outputs.
    """
    balance_df = pd.DataFrame(
        {"Value": [0, 0, 0, 0, 0]},
        index=[
            "Total current assets",
            "Total current liabilities",
            "Total assets",
            "Total liabilities",
            "Total shareholders’ equity",
        ],
    )
    income_df = pd.DataFrame(
        {"Value": [0, 0, 0, 0, 0]},
        index=[
            "Net sales",
            "Cost of sales",
            "Gross margin",
            "Total operating expenses",
            "Net income",
        ],
    )
    cash_df = pd.DataFrame(
        {"Value": [0, 0]},
        index=[
            "Cash generated by operating activities",
            "Capital Expenditures",
        ],
    )

    metrics = compute_ratios_and_metrics(balance_df, income_df, cash_df)

    assert isinstance(metrics, dict)
    # Basic checks
    assert metrics["Revenue"] == 0
    assert metrics["Net Income"] == 0
    assert metrics["CostOfRev"] == 0
    assert metrics["OpEx"] == 0
    assert metrics["Free Cash Flow"] == 0


def test_get_single_filing_snapshot_no_financials():
    mock_filing = MagicMock()
    mock_filing.form = "10-K"
    mock_filing.filing_date = "2023-01-01"
    mock_filing.company = "FAKE CO"
    mock_filing.accession_no = "123-456"
    # filing.obj() returns an object that has no `.financials`
    mock_filing.obj.return_value = MagicMock()

    mock_company = MagicMock()
    mock_company.get_filings.return_value.latest.return_value = mock_filing
    snap = get_single_filing_snapshot(mock_company, "10-K")
    assert snap["metrics"]["Revenue"] == 0.0
    assert snap["filing_info"]["form_type"] == "10-K"


def test_get_single_filing_snapshot_no_filing():
    mock_company = MagicMock()
    # means no 10-K found
    mock_company.get_filings.return_value.latest.return_value = None

    snap = get_single_filing_snapshot(mock_company, "10-K")
    assert snap["metrics"] == {}


def test_get_filing_info_missing_attributes():
    # Test if any attribute might be None or missing
    fake_filing = MagicMock()
    fake_filing.form = None
    fake_filing.filing_date = None
    fake_filing.company = None
    fake_filing.accession_no = None
    info = get_filing_info(fake_filing)
    assert info["form_type"] == "Unknown"
    assert info["filed_date"] == "Unknown"


def test_no_capex_fallback_to_investing():
    """
    If there's no row matching 'capital_expenditures', the code should fallback
    to the 'cash_flow_investing' row to estimate CapEx.
    free_cf = op_cf - (min(inv_cf, 0.0) * -1)
    """
    bs_df = pd.DataFrame(
        {"Value": [1000, 500]},
        index=["Total assets", "Total shareholders’ equity"]
    )
    inc_df = pd.DataFrame(
        {"Value": [2000, -1000]},
        index=["Net sales", "Cost of sales"]
    )
    cf_df = pd.DataFrame(
        {"Value": [800, -200]},  # -200 => negative investing CF
        index=[
            "Cash generated by operating activities",
            "Cash generated by/(used in) investing activities"
        ]
    )

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Cash from Operations"] == 800
    assert metrics["Free Cash Flow"] == 600  # 800 - 200


def test_gross_profit_none_but_revenue_present():
    """
    If gross_profit row is missing, but we do have Revenue and CostOfRev,
    the function should calculate gross_profit = revenue - cost_of_revenue.
    """
    bs_df = pd.DataFrame({"Value": [0]}, index=["Total assets"])  # minimal
    inc_df = pd.DataFrame(
        {"Value": [1500, -700]},
        index=["Net sales", "Cost of sales"]
    )
    cf_df = pd.DataFrame({"Value": [0]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Revenue"] == 1500
    assert metrics["CostOfRev"] == 700  # negative => +700
    assert metrics["Gross Profit"] == 800


def test_equity_zero_debt_equity_fallback():
    """
    If total_equity is zero or absent, 'Debt-to-Equity' should fallback to 0.0
    instead of dividing by zero.
    """
    bs_df = pd.DataFrame(
        {"Value": [1000, 0]},
        index=["Total liabilities", "Total shareholders’ equity"]
    )
    inc_df = pd.DataFrame({"Value": [1000]}, index=["Net sales"])
    cf_df = pd.DataFrame({"Value": [500]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Debt-to-Equity"] == 0


def test_alerts_negative_margin():
    """
    Net income negative => triggers negative margin alert. No low ROE alert.
    """
    bs_df = pd.DataFrame({"Value": [1000]}, index=["Total shareholders’ equity"])
    inc_df = pd.DataFrame(
        {"Value": [2000, -500]},
        index=["Net sales", "Net income"]
    )
    cf_df = pd.DataFrame(
        {"Value": [1000]},
        index=["Cash generated by operating activities"]
    )

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    alerts = metrics["Alerts"]
    assert any("Net margin below" in alert for alert in alerts)
    assert not any("ROE <" in alert for alert in alerts), \
        "Negative net income => negative ROE => not in (0, LowROE)."


def test_alerts_low_positive_roe():
    """
    Small positive net income => net margin is positive, but ROE < 5% => triggers 'ROE < 5.0%' alert.
    """
    bs_df = pd.DataFrame(
        {"Value": [10000]},
        index=["Total shareholders’ equity"]
    )
    inc_df = pd.DataFrame(
        {"Value": [2000, 100]},  # Revenue=2000, NetIncome=100 => net margin = 5%
        index=["Net sales", "Net income"]
    )
    cf_df = pd.DataFrame({"Value": [500]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    alerts = metrics["Alerts"]
    assert metrics["ROE %"] == pytest.approx(1.0, abs=1e-3)
    assert any("ROE < 5.0%" in alert for alert in alerts)

    # This scenario does NOT produce negative margin => no negative margin alert
    assert not any("Net margin below" in alert for alert in alerts)


def test_no_capex_no_investing_fallback():
    """
    Provide a CF with no matches for 'capital_expenditures' and also
    no matches for 'cash_flow_investing' synonyms. So capex_val is None,
    then we can't find investing either => free_cf should just be op_cf.
    """
    bs_df = pd.DataFrame({"Value": [1000]}, index=["Total shareholders’ equity"])  # minimal
    inc_df = pd.DataFrame({"Value": [0]}, index=["Net sales"])
    cf_df = pd.DataFrame({"Value": [999]}, index=["Some random line"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Cash from Operations"] == 0.0
    assert metrics["Free Cash Flow"] == 0.0


def test_gross_profit_nan_revenue_zero():
    """
    If 'gross_profit' is NaN/fallback, and Revenue=0, the code won't recalc.
    So 'Gross Profit' might remain 0 or NaN. We'll check final result coverage.
    """
    bs_df = pd.DataFrame({"Value": [500]}, index=["Total shareholders’ equity"])
    inc_df = pd.DataFrame({"Value": [0]}, index=["Net sales"])  # revenue=0
    cf_df = pd.DataFrame({"Value": [100]}, index=["Cash generated by operating activities"])

    metrics = compute_ratios_and_metrics(bs_df, inc_df, cf_df)
    assert metrics["Revenue"] == 0
    assert metrics["Gross Profit"] == 0.0


def test_dep_in_cogs_adjustment():
    """
    New test for logic that checks if there's a separate 'Depreciation in cost of sales'
    row and reclassifies it. We'll confirm that total D&A and cost_of_revenue are adjusted.
    """
    balance_df = pd.DataFrame(
        {"Value": [1000, 500, 1500]},
        index=["Total current assets", "Total liabilities", "Total assets"]
    )
    # Net sales=2000, Dep in COGS=100, cost_of_sales=-300 => negative => +300 if flipping
    income_df = pd.DataFrame(
        {"Value": [2000, 100, -300]},
        index=["Net sales", "Depreciation in cost of sales", "Cost of sales"]
    )
    # Normal CF
    cash_df = pd.DataFrame(
        {"Value": [800, -100]},
        index=[
            "Cash generated by operating activities",
            "Capital Expenditures",
        ]
    )

    metrics = compute_ratios_and_metrics(balance_df, income_df, cash_df)

    # We check that cost_of_sales is flipped from -300 => +300 => then minus the 100 from Dep in COGS => 200
    assert metrics["CostOfRev"] == 200, "Should remove dep_in_cogs from cost_of_revenue after flipping"
    # Depreciation in cost_of_sales was 100 => total D&A => so check EBITDA minus EBIT = 100
    ebit_val = metrics["EBIT (approx)"]
    ebitda_val = metrics["EBITDA (approx)"]
    assert ebitda_val - ebit_val == pytest.approx(100.0)

    # Also confirm Net Income isn't thrown off:
    # net_income is not directly in this test data => default 0 => no crash
    assert metrics["Net Income"] == 0.0, "If not in DF, default=0"
